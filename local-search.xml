<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络基础原理</title>
    <link href="/limoam/post/f3f5eef3.html"/>
    <url>/limoam/post/f3f5eef3.html</url>
    
    <content type="html"><![CDATA[<h1 id="网络分层模型和应用协议"><a href="#网络分层模型和应用协议" class="headerlink" title="网络分层模型和应用协议"></a>网络分层模型和应用协议</h1><h3 id="五层网络模型"><a href="#五层网络模型" class="headerlink" title="五层网络模型"></a>五层网络模型</h3><p>网络要解决的问题是： <strong>两个程序之间如何交换数据</strong>。</p><p>这是一个非常复杂的问题。</p><p>面对复杂的问题，可以使用分层的方式来简化。</p><p>经过不断的演化，网络最终形成了五层模型：</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251706600.png" alt="image-20211008163417521"></p><h3 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h3><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251709302.png" alt="image-20211008163458168"></p><h3 id="四层、五层、七层"><a href="#四层、五层、七层" class="headerlink" title="四层、五层、七层"></a>四层、五层、七层</h3><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251709352.png" alt="image-20211008164017299"></p><br /><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL（uniform resource locator，统一资源定位符）用于定位网络服务</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251708472.png" alt="image-20230112104100679"></p><p>URL 是一个固定格式的字符串</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251706555.png" alt="image-20230112102913056"></p><p>它表达了：</p><p>从网络中&#x3D;&#x3D;哪台计算机（domain）&#x3D;&#x3D;中的&#x3D;&#x3D;哪个程序（port）&#x3D;&#x3D;寻找&#x3D;&#x3D;哪个服务（path）&#x3D;&#x3D;，并注明了获取服务的&#x3D;&#x3D;具体细节（path）&#x3D;&#x3D;，以及要用什么样的&#x3D;&#x3D;协议通信（schema）&#x3D;&#x3D;</p><p>这里面包含了一些细节：</p><ul><li>当协议是<code>http</code>端口为<code>80</code>时，端口可以省略</li><li>当协议是<code>https</code>端口为<code>443</code>时，端口可以省略</li><li><code>schema</code>、<code>domain</code>、<code>path</code>是必填的，其他的根据具体的要求填写</li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议（Hyper Text Transfer Protocol，_HTTP_）是一个广泛运用于互联网的应用层协议。</p><p>99%的情况下，前端开发者接触的都是 HTTP 协议。</p><p>该协议规定了两个方面的内容：</p><ul><li><strong>传递消息的模式</strong></li><li><strong>传递消息的格式</strong></li></ul><h4 id="传递消息的模式"><a href="#传递消息的模式" class="headerlink" title="传递消息的模式"></a>传递消息的模式</h4><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251708973.png" alt="image-20230112110047746"></p><p>HTTP 使用了一种极为简单的消息传递模式，「请求-响应」模式</p><p>发起请求的称之为客户端，接收请求并完成响应的称之为服务器。</p><p>「请求-响应」完成后，一次交互结束。</p><h4 id="传递消息的格式"><a href="#传递消息的格式" class="headerlink" title="传递消息的格式"></a>传递消息的格式</h4><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251706957.png" alt="image-20230113214343300"></p><p>HTTP 的消息格式是一种纯文本的格式，文本分为三个部分：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">请求行<br>请求头<br><br>请求体<br></code></pre></td></tr></table></figure><p><strong>具体每一部分写什么内容，要看具体的服务要求</strong></p><h4 id="试一试"><a href="#试一试" class="headerlink" title="试一试"></a>试一试</h4><p>有非常多的工具可以发送 http 请求，这里推荐一个非常直观的工具</p><ol><li><p>安装<code>vscode</code>插件<code>REST Clinet</code></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251706912.png" alt="image-20230112114542925"></p></li><li><p>新建文件<code>xxx.http</code></p></li><li><p>编写请求文本</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/api/user/login</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>study.duyiedu.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">  <span class="hljs-attr">&quot;loginId&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">  <span class="hljs-attr">&quot;loginPwd&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;123123&quot;</span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure></li><li><p>发送请求</p></li></ol><h4 id="熟悉关键信息"><a href="#熟悉关键信息" class="headerlink" title="熟悉关键信息"></a>熟悉关键信息</h4><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>请求行中的第一个单词是请求方法</p><p><strong>在 HTTP 协议中，请求方法仅有语义的区别</strong>，只是表达了这次请求的「愿望」。</p><blockquote><p>关于请求方法的协议原文见 <a href="https://www.rfc-editor.org/rfc/rfc7231.html">HTTP&#x2F;1.1 规范 RFC7231-Chapter4</a></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251708393.png" alt="image-20230113190854930"></p></blockquote><p>比如<code>GET</code>表达了客户端想要获取一些东西，<code>POST</code>表达了客户端想要提交一些东西</p><p>常见的请求方法有：</p><ul><li><code>GET</code>：获取</li><li><code>POST</code>：提交</li><li><code>PUT</code>：修改</li><li><code>DELETE</code>：删除</li></ul><p><strong>具体在开发中应该选择什么请求方法，一定是看服务方的要求</strong></p><p>通常情况下：</p><ul><li>获取数据一般使用<code>GET</code></li><li>提交数据一般使用<code>POST</code></li><li>各种静态资源的获取，一般使用<code>GET</code></li></ul><h5 id="请求头-Host"><a href="#请求头-Host" class="headerlink" title="请求头 - Host"></a>请求头 - <code>Host</code></h5><p><code>Host</code>标注了<code>URL</code>地址中的<code>Domain + Port</code></p><p>示例：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Host:</span> study.duyiedu.com<br></code></pre></td></tr></table></figure><h5 id="请求头-Content-Type"><a href="#请求头-Content-Type" class="headerlink" title="请求头 - Content-Type"></a>请求头 - <code>Content-Type</code></h5><p><code>Content-Type</code>标注了附带的请求体是什么格式</p><p>比如，请求体的数据为<code>loginId:admin, loginPwd:123456</code>，请求体可以用不同的格式发出</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Content-<span class="hljs-keyword">Type</span>: application/x-www-<span class="hljs-keyword">form</span>-urlencoded<br><br>loginId=admin&amp;loginPwd=<span class="hljs-number">123123</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">Content</span>-Type: application/json<br><br>&#123; &quot;loginId&quot;: <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;loginPwd&quot;</span>: <span class="hljs-string">&quot;123123&quot;</span> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: multipart/form-data; boundary=aaa<br><br><span class="hljs-comment">--aaa</span><br>Content-Disposition: form-data; <span class="hljs-type">name</span>=&quot;loginId&quot;<br><br><span class="hljs-keyword">admin</span><br><span class="hljs-comment">--aaa</span><br>Content-Disposition: form-data; <span class="hljs-type">name</span>=&quot;loginPwd&quot;<br><br><span class="hljs-number">123456</span><br><span class="hljs-comment">--aaa</span><br>Content-Disposition: form-data; <span class="hljs-type">name</span>=&quot;avatar&quot;; filename=&quot;small.jpg&quot;<br>Content-<span class="hljs-keyword">Type</span>: image/jpeg<br><br>文件的二进制<br><span class="hljs-comment">--aaa--</span><br><br></code></pre></td></tr></table></figure><h5 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h5><p>响应码（状态码、消息码）是响应行中的一个数字，后面往往跟上一个对应的单词，用于表达服务器对这个响应的整体「态度」</p><p>常见的响应码有：</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251707538.png" alt="image-20230112131000507"></p><p>常见的状态码有：</p><ol><li><p>200 OK：一切正常。</p></li><li><p>301 Moved Permanently：资源已被永久重定向。</p><p><code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我已经永远的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了响应头的Location中了</code></p><blockquote><p>试试请求：<a href="http://www.douyutv.com/">www.douyutv.com</a></p></blockquote></li><li><p>302 Found：资源已被临时重定向。</p><p><code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我临时的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的Location中了</code></p></li><li><p>304 Not Modified：文档内容未被修改。</p><p><code>你的请求我收到了，你要的东西跟之前是一样的，没有任何的变化，所以我就不给你结果了，你自己就用以前的吧。啥？你没有缓存以前的内容，关我啥事</code></p></li><li><p>400 Bad Request：语义有误，当前请求无法被服务器理解。</p><p><code>你给我发的是个啥啊，我听都听不懂</code></p></li><li><p>403 Forbidden：服务器拒绝执行。</p><p><code>你的请求我已收到，但是我就是不给你东西</code></p></li><li><p>404 Not Found：资源不存在。</p><p><code>你的请求我收到了，但我没有你要的东西</code></p></li><li><p>500 Internal Server Error：服务器内部错误。</p><p><code>你的请求我已收到，但这道题我不会，解不出来，先睡了</code></p></li></ol><h5 id="响应头-Content-Type"><a href="#响应头-Content-Type" class="headerlink" title="响应头 - Content-Type"></a>响应头 - <code>Content-Type</code></h5><p><code>Content-Type</code>标注了附带的响应体是什么格式</p><p>常见的值有：</p><ol><li><code>text/plain</code>: 普通的纯文本</li><li><code>text/html</code>：html 文档</li><li><code>text/javascript</code> 或 <code>application/javascript</code>：js 代码</li><li><code>text/css</code>：css 代码</li><li><code>image/jpeg</code>：jpg 图片</li><li><code>attachment</code>：附件</li><li>其他<code>MIME</code>类型</li></ol><br /><h1 id="浏览器的通信能力"><a href="#浏览器的通信能力" class="headerlink" title="浏览器的通信能力"></a>浏览器的通信能力</h1><h2 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h2><p>浏览器可以代替用户完成 http 请求，代替用户解析响应结果，所以我们称之为：</p><p><strong>用户代理 user agent</strong></p><p>在网络层面，对于前端开发者，必须要知道浏览器拥有的两大核心能力：</p><ul><li>自动发出请求的能力</li><li>自动解析响应的能力</li></ul><h3 id="自动发出请求的能力"><a href="#自动发出请求的能力" class="headerlink" title="自动发出请求的能力"></a>自动发出请求的能力</h3><p>当一些事情发生的时候，浏览器会代替用户自动发出 http 请求，常见的包括：</p><ol><li><p><strong>用户在地址栏输入了一个 url 地址，并按下了回车</strong></p><p>浏览器会自动解析 URL，并发出一个<code>GET</code>请求，同时抛弃当前页面。</p></li><li><p><strong>当用户点击了页面中的 a 元素</strong></p><p>浏览器会拿到 a 元素的 href 地址，并发出一个<code>GET</code>请求，同时抛弃当前页面。</p></li><li><p><strong>当用户点击了提交按钮<code>&lt;button type=&quot;submit&quot;&gt;...&lt;/button&gt;</code></strong></p><p>浏览器会获取按钮所在的<code>&lt;form&gt;</code>元素，拿到它的<code>action</code>属性地址，同时拿到它<code>method</code>属性值，然后把表单中的数据组织到请求体中，发出<code>指定方法</code>的请求，同时抛弃当前页面。</p><blockquote><p>这种方式的提交现在越来越少见了</p></blockquote></li><li><p><strong>当解析 HTML 时遇到了<code>&lt;link&gt; &lt;img&gt; &lt;script&gt; &lt;video&gt; &lt;audio&gt;</code>等元素</strong></p><p>浏览器会拿到对应的地址，发出<code>GET</code>请求</p></li><li><p><strong>当用户点击了刷新</strong></p><p>浏览器会拿到当前页面的地址，以及当前页面的请求方法，重新发一次请求，同时抛弃当前页面。</p></li></ol><blockquote><p>浏览器在发出请求时，会自动附带一些请求头</p></blockquote><p>&#x3D;&#x3D;重点来了&#x3D;&#x3D;</p><p>从古至今，浏览器都有一个约定：</p><p><strong>当发送 GET 请求时，浏览器不会附带请求体</strong></p><p>这个约定深刻的影响着后续的前后端各种应用，现在，几乎所有人都在潜意识中认同了这一点，无论是前端开发人员还是后端开发人员。</p><p>由于前后端程序的默认行为，逐步造成了 GET 和 POST 的各种差异：</p><ol><li><p>浏览器在发送 GET 请求时，不会附带请求体</p></li><li><p>GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。</p></li><li><p>GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制</p></li><li><p>大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中</p></li><li><p>POST 不会被保存到浏览器的历史记录中</p></li><li><p>刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。</p></li></ol><h3 id="自动解析响应的能力"><a href="#自动解析响应的能力" class="headerlink" title="自动解析响应的能力"></a>自动解析响应的能力</h3><p>浏览器不仅能发送请求，还能够针对服务器的各种响应结果做出不同的自动处理</p><p>常见的处理有：</p><ol><li><p><strong>识别响应码</strong></p><p>浏览器能够自动识别响应码，当出现一些特殊的响应码时浏览器会自动完成处理，比如<code>301、302</code></p></li><li><p><strong>根据响应结果做不同的处理</strong></p><p>浏览器能够自动分析响应头中的<code>Content-Type</code>，根据不同的值进行不同处理，比如：</p><ul><li><p><code>text/plain</code>: 普通的纯文本，浏览器通常会将响应体原封不动的显示到页面上</p></li><li><p><code>text/html</code>：html 文档，浏览器通常会将响应体作为页面进行渲染</p></li><li><p><code>text/javascript</code>或<code>application/javascript</code>：js 代码，浏览器通常会使用 JS 执行引擎将它解析执行</p></li><li><p><code>text/css</code>：css 代码，浏览器会将它视为样式</p></li><li><p><code>image/jpeg</code>：浏览器会将它视为 jpg 图片</p></li><li><p><code>application/octet-stream</code>：二进制数据，会触发浏览器下载功能</p></li><li><p><code>attachment</code>：附件，会触发下载功能</p><p>该值和其他值不同，应放到<code>Content-Disposition</code>头中。</p></li></ul></li></ol><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><blockquote><p>访问：<a href="https://oss.duyiedu.com/test/index.html">https://oss.duyiedu.com/test/index.html</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/202307251717638.png" alt="image-20220428165629557"></p><br /><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><blockquote><p>浏览器本身就具备网络通信的能力，但在早期，浏览器并没有把这个能力开放给 JS。</p><p>最早是微软在 IE 浏览器中把这一能力向 JS 开放，让 JS 可以在代码中实现发送请求，并不会刷新页面，这项技术在 2005 年被正式命名为 AJAX（<strong>A</strong>synchronous <strong>J</strong>avascript <strong>A</strong>nd <strong>X</strong>ML）</p></blockquote><p>AJAX 就是指在 web 应用程序中异步向服务器发送请求。</p><p>它的实现方式有两种，<code>XMLHttpRequest 简称XHR</code>和<code>Fetch</code></p><p>以下是两者的对比</p><table><thead><tr><th>功能点</th><th>XHR</th><th>Fetch</th></tr></thead><tbody><tr><td>基本的请求能力</td><td>✅</td><td>✅</td></tr><tr><td>基本的获取响应能力</td><td>✅</td><td>✅</td></tr><tr><td>监控请求进度</td><td>✅</td><td>❌</td></tr><tr><td>监控响应进度</td><td>✅</td><td>✅</td></tr><tr><td>Service Worker 中是否可用</td><td>❌</td><td>✅</td></tr><tr><td>控制 cookie 的携带</td><td>❌</td><td>✅</td></tr><tr><td>控制重定向</td><td>❌</td><td>✅</td></tr><tr><td>请求取消</td><td>✅</td><td>✅</td></tr><tr><td>自定义 referrer</td><td>❌</td><td>✅</td></tr><tr><td>流</td><td>❌</td><td>✅</td></tr><tr><td>API 风格</td><td><code>Event</code></td><td><code>Promise</code></td></tr><tr><td>活跃度</td><td>停止更新</td><td>不断更新</td></tr></tbody></table><br /><h1 id="跨域问题及解决方案"><a href="#跨域问题及解决方案" class="headerlink" title="跨域问题及解决方案"></a>跨域问题及解决方案</h1><h2 id="同源策略及跨域问题"><a href="#同源策略及跨域问题" class="headerlink" title="同源策略及跨域问题"></a>同源策略及跨域问题</h2><p><strong>同源策略</strong>是一套浏览器<strong>安全机制</strong>，当一个<strong>源</strong>的文档和脚本，与另一个<strong>源</strong>的资源进行通信时，同源策略就会对这个通信做出不同程度的限制。</p><p>简单来说，同源策略对 <strong>同源资源</strong> <strong>放行</strong>，对 <strong>异源资源</strong> <strong>限制</strong></p><p>因此限制造成的开发问题，称之为<strong>跨域（异源）问题</strong></p><h3 id="同源和异源"><a href="#同源和异源" class="headerlink" title="同源和异源"></a>同源和异源</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">源(origin) </span>=<span class="hljs-string"> 协议 + 域名 + 端口</span><br></code></pre></td></tr></table></figure><p>例如:</p><p><code>https://study.duyiedu.com/api/movie</code>的源为<code>https://study.duyiedu.com</code></p><p><code>http://localhost:7001/index.html</code>的源为<code>http://localhost:7001</code></p><p>两个 URL 地址的源<strong>完全相同</strong>，则称之为<strong>同源</strong>，否则称之为<strong>异源（跨域）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251725856.png" alt="image-20230112163455982"></p><h3 id="跨域出现的场景"><a href="#跨域出现的场景" class="headerlink" title="跨域出现的场景"></a>跨域出现的场景</h3><p>跨域可能出现在三种场景：</p><ul><li><p><strong>网络通信</strong></p><p>a 元素的跳转；加载 css、js、图片等；AJAX 等等</p></li><li><p>JS API</p><p><code>window.open</code>、<code>window.parent</code>、<code>iframe.contentWindow</code>等等</p></li><li><p>存储</p><p><code>WebStorage</code>、<code>IndexedDB</code>等等</p></li></ul><p>对于不同的跨域场景，以及每个场景中不同的跨域方式，同源策略都有不同的限制。</p><p>本文重点讨论<strong>网络通信</strong>中<code>AJAX</code>的跨域问题</p><h3 id="网络中的跨域"><a href="#网络中的跨域" class="headerlink" title="网络中的跨域"></a>网络中的跨域</h3><p>当浏览器运行页面后，会发出很多的网络请求，例如 CSS、JS、图片、AJAX 等等</p><p>请求页面的源称之为<strong>页面源</strong>，在该页面中发出的请求称之为<strong>目标源</strong>。</p><p>当页面源和目标源一致时，则为<strong>同源请求</strong>，否则为<strong>异源请求（跨域请求）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251725539.png" alt="image-20230112163616513"></p><h3 id="浏览器如何限制异源请求？"><a href="#浏览器如何限制异源请求？" class="headerlink" title="浏览器如何限制异源请求？"></a>浏览器如何限制异源请求？</h3><p>浏览器出于多方面的考量，制定了非常繁杂的规则来限制各种跨域请求，但总体的原则非常简单：</p><ul><li>对标签发出的跨域请求轻微限制</li><li>对 AJAX 发出的跨域请求<strong>严厉限制</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251725836.png" alt="image-20230112201027855"></p><br /><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（Cross-Origin Resource Sharing）是最正统的跨域解决方案，同时也是浏览器推荐的解决方案。</p><p>CORS 是一套规则，用于帮助浏览器判断是否校验通过。</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251736864.png" alt="image-20230112202539003"></p><p>CORS 的基本理念是：</p><ul><li>只要服务器明确表示<strong>允许</strong>，则校验<strong>通过</strong></li><li>服务器明确拒绝或没有表示，则校验不通过</li></ul><p><strong>所以，使用 CORS 解决跨域，必须要保证服务器是「自己人」</strong></p><h4 id="请求分类"><a href="#请求分类" class="headerlink" title="请求分类"></a>请求分类</h4><p>CORS 将请求分为两类：&#x3D;&#x3D;简单请求&#x3D;&#x3D;和&#x3D;&#x3D;预检请求&#x3D;&#x3D;。</p><p>对不同种类的请求它的规则有所区别。</p><p>所以要理解 CORS，首先要理解它是如何划分请求的。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><blockquote><p>完整判定逻辑：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests</a></p></blockquote><p>简单来说，只要全部满足下列条件，就是简单请求：</p><ul><li><p>请求方法是<code>GET</code>、<code>POST</code>、<code>HEAD</code>之一</p></li><li><p>头部字段满足 CORS 安全规范，详见 <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">W3C</a></p><blockquote><p>浏览器默认自带的头部字段都是满足安全规范的，只要开发者不改动和新增头部，就不会打破此条规则</p></blockquote></li><li><p>如果有<code>Content-Type</code>，必须是下列值中的一个</p><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li></ul><h5 id="预检请求-preflight"><a href="#预检请求-preflight" class="headerlink" title="预检请求(preflight)"></a>预检请求(preflight)</h5><p>只要不是简单请求，均为预检请求</p><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 下面的跨域请求哪些是简单请求，哪些是预检请求</span><br><br><span class="hljs-comment">// 1 简单</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://douyin.com&#x27;</span>)<br><br><span class="hljs-comment">// 2</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://douyin.com&#x27;</span>, &#123;<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 3 简单</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://douyin.com&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 4</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://douyin.com&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="对简单请求的验证"><a href="#对简单请求的验证" class="headerlink" title="对简单请求的验证"></a>对简单请求的验证</h4><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251735812.png" alt="image-20230112204546583"></p><h4 id="对预检请求的验证"><a href="#对预检请求的验证" class="headerlink" title="对预检请求的验证"></a>对预检请求的验证</h4><ol><li>发送预检请求</li></ol><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251725889.png" alt="image-20230112204634493"></p><ol start="2"><li>发送真实请求（和简单请求一致）</li></ol><h4 id="细节-1-关于-cookie"><a href="#细节-1-关于-cookie" class="headerlink" title="细节 1 - 关于 cookie"></a>细节 1 - 关于 cookie</h4><p>默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行</p><p>不过可以通过简单的配置就可以实现附带 cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// xhr</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// fetch api</span><br><span class="hljs-title function_">fetch</span>(url, &#123;<br>  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这样一来，该跨域的 ajax 请求就是一个<em>附带身份凭证的请求</em></p><p>当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加<code>cookie</code>字段</p><p>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据</p><p>告知的方式也非常的简单，只需要在响应头中添加：<code>Access-Control-Allow-Credentials: true</code>即可</p><p>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。</p><p>另外要特别注意的是：**对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin 的值为*</code>**。这就是为什么不推荐使用*的原因.</p><h4 id="细节-2-关于跨域获取响应头"><a href="#细节-2-关于跨域获取响应头" class="headerlink" title="细节 2 - 关于跨域获取响应头"></a>细节 2 - 关于跨域获取响应头</h4><p>在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Access</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span><span class="hljs-operator">-</span><span class="hljs-variable">Expose</span><span class="hljs-operator">-</span><span class="hljs-built_in">Headers</span><span class="hljs-operator">:</span> <span class="hljs-variable">authorization</span><span class="hljs-operator">,</span> <span class="hljs-variable">a</span><span class="hljs-operator">,</span> <span class="hljs-variable">b</span><br></code></pre></td></tr></table></figure><p>这样 JS 就能够访问指定的响应头了。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>在很久很久以前…并没有 CORS 方案</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251725680.png" alt="image-20230112205454350"></p><p>在那个年代，古人靠着非凡的智慧来解决这一问题</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251725747.png" alt="image-20230112205613983"></p><p>虽然可以解决问题，但 JSONP 有着明显的缺陷：</p><ul><li><p>仅能使用 GET 请求</p></li><li><p>容易产生安全隐患</p><blockquote><p>恶意攻击者可能利用<code>callback=恶意函数</code>的方式实现<code>XSS</code>攻击</p></blockquote></li><li><p>容易被非法站点恶意调用</p></li></ul><p><strong>因此，除非是某些特殊的原因，否则永远不应该使用 JSONP</strong></p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>CORS 和 JSONP 均要求服务器是「自己人」</p><p>那如果不是呢？</p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251725611.png" alt="image-20230112210551647" style="zoom:50%;" /><p>那就找一个中间人（代理）</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251730930.png" alt="image-20230115133326930"></p><p>比如，前端小王想要请求获取王者荣耀英雄数据，但直接请求腾讯服务器会造成跨域</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251730549.png" alt="image-20230115133732560"></p><p>由于腾讯服务器不是「自己人」，小王决定用代理解决</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251730272.png" alt="image-20230115133817554"></p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>最重要的，是要保持<strong>生产环境和开发环境一致</strong></p><p>下面是一张决策图</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251726414.png" alt="image-20230115145335319"></p><p>具体的几种场景</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251726777.png" alt="image-20230115150610750"></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/network/req/202307251726881.png" alt="image-20230115151406797"></p>]]></content>
    
    
    <categories>
      
      <category>网络原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>歌词滚动效果练习</title>
    <link href="/limoam/post/dbf46da.html"/>
    <url>/limoam/post/dbf46da.html</url>
    
    <content type="html"><![CDATA[<h1 id="歌词滚动效果练习"><a href="#歌词滚动效果练习" class="headerlink" title="歌词滚动效果练习"></a>歌词滚动效果练习</h1><h2 id="首先我们要绘制如图所示静态页面"><a href="#首先我们要绘制如图所示静态页面" class="headerlink" title="首先我们要绘制如图所示静态页面"></a>首先我们要绘制如图所示静态页面</h2><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/lyrics-roll/202307261027251.png" alt="image-20230726102735100"></p><blockquote><p>这方面无需多言，body设置为黑色， text-align: center等</p><p>audio设置宽度，由于audio属于行盒（浏览器默认样式没有为它设置display，默认display为inline，但具有内置的宽高属性，某些情况下也可看作替换元素，所以具有设置宽高的能力）<img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/lyrics-roll/202307261039455.png" alt="image-20230726103932400"></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/lyrics-roll/202307261048172.png" alt="image-20230726104834106"></p><p>歌词我们设置一个包含块，内部采用<code>ul&gt;li</code>来实现</p></blockquote><h2 id="接下来对数据进行处理"><a href="#接下来对数据进行处理" class="headerlink" title="接下来对数据进行处理"></a>接下来对数据进行处理</h2><h3 id="首先可以看到数据是放在js文件全局引入暴露的一个js字符串（真实场景应该由服务器返回）"><a href="#首先可以看到数据是放在js文件全局引入暴露的一个js字符串（真实场景应该由服务器返回）" class="headerlink" title="首先可以看到数据是放在js文件全局引入暴露的一个js字符串（真实场景应该由服务器返回）"></a>首先可以看到数据是放在js文件全局引入暴露的一个js字符串（真实场景应该由服务器返回）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> lrc = <span class="hljs-string">`[00:01.06]难念的经</span><br><span class="hljs-string">[00:03.95]演唱：周华健</span><br><span class="hljs-string">[00:06.78]</span><br><span class="hljs-string">[00:30.96]笑你我枉花光心计</span><br><span class="hljs-string">[00:34.15]爱竞逐镜花那美丽</span><br><span class="hljs-string">[00:36.75]怕幸运会转眼远逝</span><br><span class="hljs-string">[00:39.32]为贪嗔喜恶怒着迷</span><br><span class="hljs-string">[00:41.99]责你我太贪功恋势</span><br><span class="hljs-string">[00:44.48]怪大地众生太美丽</span><br><span class="hljs-string">[00:47.00]悔旧日太执信约誓</span><br><span class="hljs-string">[00:49.66]为悲欢哀怨妒着迷</span><br><span class="hljs-string">[00:52.56]啊 舍不得璀灿俗世</span><br><span class="hljs-string">[00:57.66]啊 躲不开痴恋的欣慰</span><br><span class="hljs-string">[01:02.86]啊 找不到色相代替</span><br><span class="hljs-string">[01:08.09]啊 参一生参不透这条难题</span><br><span class="hljs-string">[01:13.15]吞风吻雨葬落日未曾彷徨</span><br><span class="hljs-string">[01:15.73]欺山赶海践雪径也未绝望</span><br><span class="hljs-string">[01:18.23]拈花把酒偏折煞世人情狂</span><br><span class="hljs-string">[01:20.90]凭这两眼与百臂或千手不能防</span><br><span class="hljs-string">[01:23.76]天阔阔雪漫漫共谁同航</span><br><span class="hljs-string">[01:26.09]这沙滚滚水皱皱笑着浪荡</span><br><span class="hljs-string">[01:28.68]贪欢一刻偏教那女儿情长埋葬</span><br><span class="hljs-string">[01:32.38]</span><br><span class="hljs-string">[01:34.09]吞风吻雨葬落日未曾彷徨</span><br><span class="hljs-string">[01:36.50]欺山赶海践雪径也未绝望</span><br><span class="hljs-string">[01:39.07]拈花把酒偏折煞世人情狂</span><br><span class="hljs-string">[01:41.69]凭这两眼与百臂或千手不能防</span><br><span class="hljs-string">[01:44.68]天阔阔雪漫漫共谁同航</span><br><span class="hljs-string">[01:46.93]这沙滚滚水皱皱笑着浪荡</span><br><span class="hljs-string">[01:49.54]贪欢一刻偏教那女儿情长埋葬</span><br><span class="hljs-string">[01:53.41]</span><br><span class="hljs-string">[02:15.45]笑你我枉花光心计</span><br><span class="hljs-string">[02:18.53]爱竞逐镜花那美丽</span><br><span class="hljs-string">[02:21.14]怕幸运会转眼远逝</span><br><span class="hljs-string">[02:23.76]为贪嗔喜恶怒着迷</span><br><span class="hljs-string">[02:26.43]责你我太贪功恋势</span><br><span class="hljs-string">[02:28.98]怪大地众生太美丽</span><br><span class="hljs-string">[02:31.60]悔旧日太执信约誓</span><br><span class="hljs-string">[02:34.26]为悲欢哀怨妒着迷</span><br><span class="hljs-string">[02:36.90]啊 舍不得璀灿俗世</span><br><span class="hljs-string">[02:42.04]啊 躲不开痴恋的欣慰</span><br><span class="hljs-string">[02:47.34]啊 找不到色相代替</span><br><span class="hljs-string">[02:52.52]啊 参一生参不透这条难题</span><br><span class="hljs-string">[02:57.47]吞风吻雨葬落日未曾彷徨</span><br><span class="hljs-string">[03:00.05]欺山赶海践雪径也未绝望</span><br><span class="hljs-string">[03:02.64]拈花把酒偏折煞世人情狂</span><br><span class="hljs-string">[03:05.27]凭这两眼与百臂或千手不能防</span><br><span class="hljs-string">[03:08.22]天阔阔雪漫漫共谁同航</span><br><span class="hljs-string">[03:10.49]这沙滚滚水皱皱笑着浪荡</span><br><span class="hljs-string">[03:13.06]贪欢一刻偏教那女儿情长埋葬</span><br><span class="hljs-string">[03:18.45]吞风吻雨葬落日未曾彷徨</span><br><span class="hljs-string">[03:20.90]欺山赶海践雪径也未绝望</span><br><span class="hljs-string">[03:23.54]拈花把酒偏折煞世人情狂</span><br><span class="hljs-string">[03:26.21]凭这两眼与百臂或千手不能防</span><br><span class="hljs-string">[03:29.07]天阔阔雪漫漫共谁同航</span><br><span class="hljs-string">[03:31.32]这沙滚滚水皱皱笑着浪荡</span><br><span class="hljs-string">[03:33.92]贪欢一刻偏教那女儿情长埋葬</span><br><span class="hljs-string">[03:39.32]吞风吻雨葬落日未曾彷徨</span><br><span class="hljs-string">[03:41.84]欺山赶海践雪径也未绝望</span><br><span class="hljs-string">[03:44.38]拈花把酒偏折煞世人情狂</span><br><span class="hljs-string">[03:47.04]凭这两眼与百臂或千手不能防</span><br><span class="hljs-string">[03:49.99]天阔阔雪漫漫共谁同航</span><br><span class="hljs-string">[03:52.20]这沙滚滚水皱皱笑着浪荡</span><br><span class="hljs-string">[03:54.89]贪欢一刻偏教那女儿情长埋葬</span><br><span class="hljs-string">[04:00.28]吞风吻雨葬落日未曾彷徨</span><br><span class="hljs-string">[04:02.68]欺山赶海践雪径也未绝望</span><br><span class="hljs-string">[04:05.25]拈花把酒偏折煞世人情狂</span><br><span class="hljs-string">[04:07.90]凭这两眼与百臂或千手不能防</span><br><span class="hljs-string">[04:10.85]天阔阔雪漫漫共谁同航</span><br><span class="hljs-string">[04:13.08]这沙滚滚水皱皱笑着浪荡</span><br><span class="hljs-string">[04:15.75]贪欢一刻偏教那女儿情长埋葬</span><br><span class="hljs-string">[04:19.48]`</span><br></code></pre></td></tr></table></figure><h3 id="首先要处理这段字符串，转化为我们可操作的js对象数组等，方便我们对最后效果展示"><a href="#首先要处理这段字符串，转化为我们可操作的js对象数组等，方便我们对最后效果展示" class="headerlink" title="首先要处理这段字符串，转化为我们可操作的js对象数组等，方便我们对最后效果展示"></a>首先要处理这段字符串，转化为我们可操作的js对象数组等，方便我们对最后效果展示</h3><ul><li>按照数据展示的思路将字符串转化为我们认识的 **[{time:1.06,words:’难念的经’}。{}，…]**这种格式</li></ul><h3 id="接下来便是如何转化的问题，这里采用如下方式将每条歌词转化为-time：开始时间，-words-歌词内容-的对象，然后推入一个数组中"><a href="#接下来便是如何转化的问题，这里采用如下方式将每条歌词转化为-time：开始时间，-words-歌词内容-的对象，然后推入一个数组中" class="headerlink" title="接下来便是如何转化的问题，这里采用如下方式将每条歌词转化为{time：开始时间， words: 歌词内容}的对象，然后推入一个数组中"></a>接下来便是如何转化的问题，这里采用如下方式将每条歌词转化为<code>&#123;time：开始时间， words: 歌词内容&#125;</code>的对象，然后推入一个数组中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseLrc</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> lrc.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 以&#x27;]&#x27;分为一个数组  [&#x27;[00:01.06&#x27;, &#x27;难念的经&#x27;]</span><br>    <span class="hljs-keyword">const</span> arr = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;]&#x27;</span>) <br>    <span class="hljs-comment">// 对时间数据进行截取并转换为数组 [&#x27;00&#x27;, &#x27;01.06&#x27;]</span><br>    <span class="hljs-keyword">const</span> timeMsg = arr[<span class="hljs-number">0</span>].<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br><br>    <span class="hljs-keyword">const</span> obj = &#123;<br>      <span class="hljs-attr">time</span>: timeMsg[<span class="hljs-number">0</span>] * <span class="hljs-number">60</span> + +timeMsg[<span class="hljs-number">1</span>], <span class="hljs-comment">// 对时间数据转化为以秒为单位的数据</span><br>      <span class="hljs-attr">words</span>: arr[<span class="hljs-number">1</span>] <span class="hljs-comment">// 歌词</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">const</span> lrcData = <span class="hljs-title function_">parseLrc</span>()<br></code></pre></td></tr></table></figure><ul><li>得到如下数据：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/lyrics-roll/202307261104686.png" alt="image-20230726110447640"></p><h3 id="数据处理完成便是处理如何添加元素以及在正确时间显示正确歌词样式"><a href="#数据处理完成便是处理如何添加元素以及在正确时间显示正确歌词样式" class="headerlink" title="数据处理完成便是处理如何添加元素以及在正确时间显示正确歌词样式"></a>数据处理完成便是处理如何添加元素以及在正确时间显示正确歌词样式</h3><ul><li>将需要用到的dom包装为一个对象，然后进行获取正确时间歌词数组对应的下标</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取需要的dom，从开始设计实现陆续添加dom，这里为最终所需dom对象</span><br><span class="hljs-keyword">let</span> doms = &#123;<br>  <span class="hljs-attr">audio</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;audio&#x27;</span>),<br>  <span class="hljs-attr">ul</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.lrc-list&#x27;</span>),<br>  <span class="hljs-attr">container</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 计算出在当前播放器第几秒</span><br><span class="hljs-comment">* lrcData数组中，应该哪个下标高亮</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findIndex</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 播放器当前时间</span><br>  <span class="hljs-keyword">const</span> curTime = doms.<span class="hljs-property">audio</span>.<span class="hljs-property">currentTime</span><br>  <span class="hljs-comment">// 遍历歌词数组，如果当前时间小于歌词数组某一项，返回前一项的下标</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lrcData.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (curTime &lt; lrcData[i].<span class="hljs-property">time</span>) &#123;<br>      <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果最后时间大于所有歌词时间，返回歌词最后一个下标</span><br>  <span class="hljs-keyword">return</span> lrcData.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="经过如上操作，所有需要的数据已经处理并且拿到，接下来便是操作dom进行展示"><a href="#经过如上操作，所有需要的数据已经处理并且拿到，接下来便是操作dom进行展示" class="headerlink" title="经过如上操作，所有需要的数据已经处理并且拿到，接下来便是操作dom进行展示"></a>经过如上操作，所有需要的数据已经处理并且拿到，接下来便是操作dom进行展示</h3><ol><li><p>创建歌词的dom元素，样式等早已在静态页面便设置好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initLrcElements</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 文档片段 批量添加  改动了Ddom树,最好批量添加 </span><br>  <span class="hljs-keyword">let</span> frag = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()<br>  lrcData.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br>    li.<span class="hljs-property">textContent</span> = item.<span class="hljs-property">words</span><br>    frag.<span class="hljs-title function_">appendChild</span>(li) <br>  &#125;)<br>  doms.<span class="hljs-property">ul</span>.<span class="hljs-title function_">appendChild</span>(frag)<br>&#125;<br><span class="hljs-title function_">initLrcElements</span>()<br></code></pre></td></tr></table></figure></li><li><p>接下来便是对播放事件的监听以及对dom元素的动态效果的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> containerHeight = doms.<span class="hljs-property">container</span>.<span class="hljs-property">clientHeight</span> <span class="hljs-comment">// 容器高度</span><br><span class="hljs-keyword">const</span> liHeight = doms.<span class="hljs-property">ul</span>.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">clientHeight</span> <span class="hljs-comment">// 元素高度</span><br><span class="hljs-keyword">const</span> maxOffset = doms.<span class="hljs-property">ul</span>.<span class="hljs-property">clientHeight</span> - containerHeight <span class="hljs-comment">// 最大偏移量</span><br><span class="hljs-comment">// /**</span><br><span class="hljs-comment">//  * 设置ul元素的偏移量</span><br><span class="hljs-comment">//  */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setOffset</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">findIndex</span>() <span class="hljs-comment">// 得到显示高亮元素的下标</span><br>  <span class="hljs-comment">// index从0开始，所以偏移量就是歌词前几条的高度+本条高度的一半再减去容器高度一般就是正中间</span><br>  <span class="hljs-keyword">let</span> offset = liHeight * index + liHeight / <span class="hljs-number">2</span> - containerHeight / <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// 规定偏移量的范围</span><br>  <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>    offset = <span class="hljs-number">0</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (offset &gt; maxOffset) &#123;<br>    offset = maxOffset<br>  &#125;<br>    <br>  <span class="hljs-comment">// 采用c3位移，不会有重排重绘，优化性能</span><br>  doms.<span class="hljs-property">ul</span>.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translateY(-<span class="hljs-subst">$&#123;offset&#125;</span>px)`</span><br>  <span class="hljs-comment">// 去掉有高亮等样式的元素上的active</span><br>  doms.<span class="hljs-property">ul</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.active&#x27;</span>)?.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>  <span class="hljs-comment">// 给当前元素架上active即可</span><br>  <span class="hljs-keyword">const</span> li = doms.<span class="hljs-property">ul</span>.<span class="hljs-property">children</span>[index]<br>  <span class="hljs-keyword">if</span> (li) &#123;<br>    li.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后给元素监听事件即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">doms.<span class="hljs-property">audio</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;timeupdate&#x27;</span>, setOffset)<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>如此，一个歌词滚动效果便完成了</p></blockquote><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/lyrics-roll/202307261402261.gif" alt="123456"></p>]]></content>
    
    
    <categories>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="/limoam/post/a074b2a4.html"/>
    <url>/limoam/post/a074b2a4.html</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307231744172.png" alt="image-20230723174402064"></p><blockquote><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307231745455.png" alt="image-20230723174502402"></p><br /><blockquote><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723175728602.png" alt="image-20230723175728602"></p><br /><h3 id="渲染的第一步是解析-HTML。"><a href="#渲染的第一步是解析-HTML。" class="headerlink" title="渲染的第一步是解析 HTML。"></a>渲染的第一步是<strong>解析 HTML</strong>。</h3><blockquote><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p></blockquote><blockquote><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180008222.png" alt="image-20230723180008222"></p><blockquote><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180037817.png" alt="image-20230723180037817"></p><blockquote><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723175905655.png" alt="image-20230723175905655"></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723175936479.png" alt="image-20230723175936479"></p><br /><h3 id="渲染的下一步是样式计算。"><a href="#渲染的下一步是样式计算。" class="headerlink" title="渲染的下一步是样式计算。"></a>渲染的下一步是<strong>样式计算</strong>。</h3><blockquote><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p></blockquote><blockquote><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180138036.png" alt="image-20230723180138036"></p><br /><h3 id="接下来是布局，布局完成后会得到布局树。"><a href="#接下来是布局，布局完成后会得到布局树。" class="headerlink" title="接下来是布局，布局完成后会得到布局树。"></a>接下来是<strong>布局</strong>，布局完成后会得到布局树。</h3><blockquote><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180307492.png" alt="image-20230723180307492"></p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180358242.png" alt="image-20230723180358242"></p><br /><h3 id="下一步是分层"><a href="#下一步是分层" class="headerlink" title="下一步是分层"></a>下一步是<strong>分层</strong></h3><blockquote><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180419700.png" alt="image-20230723180419700"></p><blockquote><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p></blockquote><br /><h3 id="再下一步是绘制"><a href="#再下一步是绘制" class="headerlink" title="再下一步是绘制"></a>再下一步是<strong>绘制</strong></h3><blockquote><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180442524.png" alt="image-20230723180442524"></p><br /><h3 id="完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。"><a href="#完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。" class="headerlink" title="完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。"></a>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</h3><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180520089.png" alt="image-20230723180520089"></p><blockquote><p>合成线程首先对每个图层进行<strong>分块</strong>，将其划分为更多的小区域。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180547082.png" alt="image-20230723180547082"></p><blockquote><p>它会从线程池中拿取多个线程来完成分块工作。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180606770.png" alt="image-20230723180606770"></p><br /><h3 id="分块完成后，进入光栅化阶段。"><a href="#分块完成后，进入光栅化阶段。" class="headerlink" title="分块完成后，进入光栅化阶段。"></a>分块完成后，进入<strong>光栅化</strong>阶段。</h3><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180636823.png" alt="image-20230723180636823"></p><blockquote><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180655962.png" alt="image-20230723180655962"></p><blockquote><p>光栅化的结果，就是一块一块的位图</p></blockquote><br /><h3 id="最后一个阶段就是画了"><a href="#最后一个阶段就是画了" class="headerlink" title="最后一个阶段就是画了"></a>最后一个阶段就是<strong>画</strong>了</h3><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/image-20230723180724913.png" alt="image-20230723180724913"></p><blockquote><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p></blockquote><br /><h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><blockquote><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p></blockquote><h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><blockquote><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p></blockquote><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><blockquote><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>浏览器基础原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新看待JS事件循环</title>
    <link href="/limoam/post/3dde9905.html"/>
    <url>/limoam/post/3dde9905.html</url>
    
    <content type="html"><![CDATA[<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><h3 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a>何为进程？</h3><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307230957513.png" alt="image-20220809210859457"></p><p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意</p><br /><h3 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h3><p>有了进程后，就可以运行程序的代码了。</p><p>运行代码的「人」称之为「线程」。</p><p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p><p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。<img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307230958236.png" alt="image-20220809210859457"></p><br /><h3 id="浏览器有哪些进程和线程？"><a href="#浏览器有哪些进程和线程？" class="headerlink" title="浏览器有哪些进程和线程？"></a>浏览器有哪些进程和线程？</h3><p><strong>浏览器是一个多进程多线程的应用程序</strong></p><p>浏览器内部工作极其复杂。</p><p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307230958714.png" alt="image-20220809213152371"></p><blockquote><p>可以在浏览器的任务管理器中查看当前的所有进程</p></blockquote><p>其中，最主要的进程有：</p><ol><li><p>浏览器进程</p><p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p></li><li><p>网络进程</p><p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p></li><li><p><strong>渲染进程</strong>（本节课重点讲解的进程）</p><p>渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。</p><p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p><blockquote><p>将来该默认模式可能会有所改变，有兴趣的同学可参见<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability">chrome 官方说明文档</a></p></blockquote></li></ol><br /><h2 id="渲染主线程是如何工作的？"><a href="#渲染主线程是如何工作的？" class="headerlink" title="渲染主线程是如何工作的？"></a>渲染主线程是如何工作的？</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画 60 次</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>……</li></ul><blockquote><p>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p></blockquote><p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p><p>比如：</p><ul><li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li><li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li><li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li><li>……</li></ul><p>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307230958785.png" alt="image-20220809223027806"></p><ol><li>在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li><li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li></ol><p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p><p><strong>整个过程，被称之为事件循环（消息循环）</strong></p><br /><h2 id="若干解释"><a href="#若干解释" class="headerlink" title="若干解释"></a>若干解释</h2><h3 id="何为异步？"><a href="#何为异步？" class="headerlink" title="何为异步？"></a>何为异步？</h3><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p><ul><li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code></li><li>网络通信完成后需要执行的任务 – <code>XHR</code>、<code>Fetch</code></li><li>用户操作后需要执行的任务 – <code>addEventListener</code></li></ul><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307230958439.png" alt="image-20220810104344296"></p><p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p><p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/event-loop/202307230958496.png" alt="image-20220810104858857"></p><p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p><blockquote><p>如何理解 JS 的异步？</p><p>JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></blockquote><br /><h3 id="JS-为何会阻碍渲染？"><a href="#JS-为何会阻碍渲染？" class="headerlink" title="JS 为何会阻碍渲染？"></a>JS 为何会阻碍渲染？</h3><p>先看代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Mr.Yuan is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>change<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> h1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 死循环指定的时间</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">duration</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()</span><br><span class="language-javascript">    <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; duration) &#123;&#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    h1.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;袁老师很帅！&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-title function_">delay</span>(<span class="hljs-number">3000</span>)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击按钮后，会发生什么呢？</p><ul><li><p>首先当我们点击按钮的时候，会执行函数回调</p></li><li><p>当执行函数会掉时可以看到页面会卡顿 3 秒左右页面才会显示</p></li><li><p>这是由于先执行了修改 h1 内容的代码，这时 h1 内容已经发生改变，但未什么界面没有立即发生变化呢？</p><ol><li>触发的事件是个回调函数，一个函数是一“任务”，只有当函数内全部执行完成才会执行其他任务，比如渲染任务等；</li><li>修改完 h1 后这时候会触发死循，根据传入的参数执行相应次数，这时页面进入了类似“卡顿”的状态，但这并不是渲染主线程阻塞，只是在渲染主线程中正在执行 JS 死循环的任务，阻碍了渲染任务；</li><li>当 3 秒过后主线程 JS 执行完毕，这时候才把渲染任务等放入渲染主线程中执行，这便是为什么 JS 会阻碍页面渲染。</li></ol></li></ul><br /><h3 id="任务有优先级吗？"><a href="#任务有优先级吗？" class="headerlink" title="任务有优先级吗？"></a>任务有优先级吗？</h3><p>任务没有优先级，在消息队列中先进先出</p><p>但<strong>消息队列是有优先级的</strong></p><p>根据 W3C 的最新解释:</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li></ul><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p></blockquote><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>微队列：用户存放需要最快执行的任务，优先级「最高」</li></ul><br /><blockquote><p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即把一个函数添加到微队列</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(函数)<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p></blockquote><br /><blockquote><p>总结：JS 的事件循环</p><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p></blockquote><br /><blockquote><p>问：JS 中的计时器能做到精确计时吗？为什么？</p><p>不行，因为：</p><ol><li>计算机硬件没有原子钟，无法做到精确计时</li><li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>浏览器基础原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端前置知识</title>
    <link href="/limoam/post/8579c272.html"/>
    <url>/limoam/post/8579c272.html</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器渲染引擎"><a href="#浏览器渲染引擎" class="headerlink" title="浏览器渲染引擎"></a>浏览器渲染引擎</h1><ul><li><p>浏览器最核心的部分是<strong>渲染引擎</strong>，也称<strong>浏览器内核</strong></p><ul><li>负责<strong>解析网页语法</strong>，并<strong>渲染（显示）网页</strong></li></ul></li></ul><br /><ul><li><p>常见浏览器内核：</p><ul><li><p><strong>Trident</strong>（三叉戟）：IE、360 安全浏览器、搜狗高速浏览器、百度浏览器、UC 浏览器</p></li><li><p><strong>Gecko</strong>（壁虎）：Mozilla Firefox</p></li><li><p><strong>Presto</strong>（急板乐曲）–&gt; <strong>Blink</strong>（眨眼）：Opera</p></li><li><p><strong>Webkit</strong> ：Safari、360 极速浏览器、搜狗高速浏览器、移动端浏览器</p></li><li><p><strong>Webkit</strong> –&gt; <strong>Blink</strong> : Google Chrome</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241019677.png" alt="image-20230724101939597"></p><ul><li>不同浏览器内核有不同解析、渲染规则，所以同一网页在不同内核浏览器渲染效果也可能不同</li></ul><br /><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li><p>是一种用于创建<strong>网页</strong>的<strong>标记语言</strong></p></li><li><p>什么是标记语言？</p><ol><li><p>由无数个<strong>标记（标签、Tag）</strong>组成</p></li><li><p>是对某些特殊内容进行特殊的标记，以供其他<strong>解释器识别处理</strong></p></li><li><p>比如说使用<code>&lt;h1&gt;&lt;/h1&gt;</code>标记的文本会被识别为“<strong>标题</strong>”，进行<strong>加粗、文字放大</strong>显示</p></li><li><p>由<strong>标签和内容</strong>组成的部分被称为<strong>元素（element）</strong></p></li></ol></li></ul><br /><ul><li><p>什么是超文本（HyperText）呢？</p><ul><li><p>不仅可以插入普通的文本，还可以插入<strong>图片、视频、音频</strong>等内容</p></li><li><p>还可以表示<strong>超链接（HyperText）</strong>，从一个网页跳转到另一个网页</p></li></ul></li></ul><br /><ul><li><p>HTML 文件的拓展名是**.htm 和.html**</p><ul><li><p>历史遗留问题，win95&#x2F;win98 系统文件扩展名不能超过 3 位</p></li><li><p>现在统一使用**.html**</p></li></ul></li></ul><br /><ul><li>一个 HTML 元素由标签、内容、属性构成，元素之间由父子、兄弟关系</li><li>一个完整的 HTML 文档由文档声明<code>&lt;!DOCTYPE html&gt;</code>与<strong>HTML 元素</strong>组成</li></ul><br /><ul><li><p><code>&lt;!DOCTYPE html&gt;</code>用于声明文档类型，文档版本（DocumentType）</p><ul><li>告诉浏览器是 HTML5 页面</li><li>让浏览器用 HTML5 的标准去解析识别内容</li><li>必须放在 HTML 文档的最前面，不能省略，省略会出现兼容性问题</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241022425.png" alt="image-20230724102246371"></p><br /><ul><li><p>W3C 标准建议为 html 元素增加一个<strong>lang 属性</strong></p><ul><li>作用是帮助<strong>语音合成工具</strong>确定要使用的发音</li><li>帮助<strong>翻译工具</strong>确定要使用的翻译规则</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241024702.png" alt="image-20230724102412665"></p><br /><ul><li><p>HTML head 元素规定<strong>文档相关配置信息（也成为元数据）</strong>，包括<strong>文档的个标题</strong>、<strong>引用的文档样式</strong>、<strong>文档脚本</strong>等，可以理解为对整个页面的配置。</p><ul><li><p>网页的标题，<code>&lt;title&gt;&lt;/title&gt;</code>元素</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241025500.png" alt="image-20230724102540457"></p></li><li><p><code>&lt;meta&gt;</code>元素</p><ul><li><p>可以设置网页的字符编码，让浏览器更精准的显示每一个文字，<strong>不设置或设置错误会导致乱码</strong></p></li><li><p>一般使用<strong>utf-8 编码</strong>，涵盖世界上几乎所有文字</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241026638.png" alt="image-20230724102603602"></p></li></ul></li></ul></li><li><p>标题元素（heading）h1—-h6，浏览器如何区分（呈现时）：通过 css 默认样式表</p></li></ul><br /><ul><li><p><code>&lt;img&gt;</code>alt 属性：</p><ul><li><p>图片加载不成功显示这段文本</p></li><li><p>屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义</p></li><li><p>搭建服务器的页面 img 的 src 无法使用 file 协议绝对路径找到图片</p><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241027275.png" alt="image-20230724102720216"></p></li></ul></li></ul><br /><ul><li><p>a 链接可以指向压缩包文件、指向其他协议地址等</p><ul><li><p><code>&lt;a href=&quot;mailto:123@qq.com&quot;&gt;&lt;/a&gt;</code></p></li><li><p>target 属性：<code>_self，_blank，_parent，_top</code></p></li></ul></li></ul><br /><ul><li><p><code>&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;</code>元素可以实现在 HTML 文档中嵌套其他的 HTML 文档</p><ul><li><p>阻止 iframe 嵌套网页：rsoponse header 中设置 X-Frame-Options: sameotigin(同源)</p></li><li><p>frameborder 设置边框：0 和 1</p></li></ul></li></ul><br /><ul><li><p>div 元素、span 元素的历史</p><ul><li><p>div 元素：division，分开、分配的意思</p></li><li><p>span 元素：跨域、涵盖的意思</p></li><li><p>都是纯粹的容器，div 用来分隔独立部分，span 用于区分特殊文本和普通文本</p></li></ul></li></ul><br /><ul><li>HTML 全局属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes">全局属性 - HTML（超文本标记语言） | MDN (mozilla.org)</a></li></ul><br /><h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h2 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h2><ul><li>由于某些特殊字符浏览器解析会初吻题，比如 “ &lt; ” 浏览器会当作一个标签的符号解析，某些情况下我们确实需要这个符号，这时候可以用字符实体。</li><li>HTML 实体是<code>&amp;……;</code>的字符串：<ul><li>常用于显示保留字符（这些字符会被解析为 HTML 代码）和不可见字符（换行空格等）</li><li>也可以用实体代替其他难以用标准键盘键入的字符</li><li><code>&amp;nbsp;</code>,<code>&amp;lt;</code>,<code>&amp;gt;</code>等</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241029688.png" alt="image-20230724102943624"></p><br /><h2 id="认识-URL"><a href="#认识-URL" class="headerlink" title="认识 URL"></a>认识 URL</h2><ul><li><strong>URL</strong>代表着统一资源<strong>定位符</strong>（Uniform Resource Locator）<ul><li><strong>通俗来讲</strong>：URL 是一个给定的独特资源在 web 上的地址</li><li><strong>URL 格式</strong>：<code>[协议类型]://[服务器地址]:[端口号]/[文件路径][文件名]?[查询]#[片段ID]</code></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241030712.png" alt="image-20230724103005651"></p><ul><li><strong>URI</strong>代表着统一资源<strong>标识符</strong>，用于标识<strong>Web 技术使用的逻辑或物理资源</strong><ul><li><strong>URI 在某一个规则下能把一个资源独一无二的识别出来</strong></li><li>URL 作为一个网络 Web 资源的地址，可以唯一将一个资源识别出来，所以 URL 是一个 URI</li><li>所以 URL 是 URI 的一个子集</li><li>但是 URI 并不一定是 URL</li></ul></li></ul><br /><h2 id="元素语义化"><a href="#元素语义化" class="headerlink" title="元素语义化"></a>元素语义化</h2><ul><li>意思是用正确的元素做正确的事情</li><li>方便代码维护</li><li>减少让开发者之间沟通的成本</li><li>能够让语音合成工具正确识别网页元素用途，以便做出正确的反应</li><li>有利于 seo</li></ul><br /><h2 id="SEO-的理解"><a href="#SEO-的理解" class="headerlink" title="SEO 的理解"></a>SEO 的理解</h2><ul><li>搜索引擎优化（英语：search engine optimization，缩写为 SEO）是通过了解搜索引擎的运作规则来调整网站，以及提高网站在有关搜索引擎内排名的方式</li></ul><br /><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p><img src="https://cdn.jsdelivr.net/gh/limoam/blog.img/base/202307241030013.png" alt="image-20230724103046973"></p><ul><li><strong>计算机是干什么的?</strong><ul><li>计算机一开始发明出来时是用来解决数字计算问题的，后来人们发现，计算机还可以做更多的事，例如文本处理。</li><li>但计算机其实挺笨的，它只“认识”010110111000…这样由 0 和 1 两个数字组成的二进制数字；</li><li>这是因为计算机的底层硬件实现就是用电路的开和闭两种状态来表示 0 和 1 两个数字的。</li><li>因此，计算机只可以直接存储和处理二进制数字。</li></ul></li><li>为了在计算机上也<strong>能表示、存储和处理像文字、符号等等之类的字符</strong>，就必须将这些<strong>字符转换成二进制</strong>数字。<ul><li>当然，肯定不是我们想怎么转换就怎么转换，否则就会造成同一段二进制数字在不同计算机上显示出来的字符不一样的情况，</li><li>因此必须得定一个统一的、标准的转换规则</li><li>字符编码的发展历史可以阅读简书一篇文章：<a href="https://www.jianshu.com/p/899e749be47c">https://www.jianshu.com/p/899e749be47c</a></li></ul></li></ul><br /><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p>CSS 表示层叠样式表，是为网页添加<strong>样式的代码</strong></p></li><li><p>早期的网页都是<strong>通过 HTML 来编写</strong>的，但是我们希望<strong>HTML 页面可以更加丰富:</strong></p><ul><li>这个时候就增加了很多<strong>具备特殊样式的元素</strong>：比如 i、strong、del 等等</li><li>后来也有不同的浏览器<strong>实现各自的样式语言</strong>，但是没有统一的规划</li><li>1994 年，哈肯·维姆·莱和伯特·波斯<strong>合作设计 CSS</strong>，在 1996 年的时候发布了<strong>CSS1</strong></li><li>直到 1997 年初，W3C 组织才专门<strong>成立了 CSS 的工作组</strong>，1998 年 5 月发布了<strong>CSS2</strong></li><li>在 2006~2009 非常流行<strong>“DIV+CSS”布局</strong>的方式来替代所有的 html 标签</li><li>从 CSS3 开始，所有的 CSS 分成了<strong>不同的模块（modules）</strong>，每一个“modules”都有于 CSS2 中额外增加的功能，以及向后兼容</li><li>直到 2011 年 6 月 7 日，<strong>CSS 3 Color Module</strong>终于发布为 W3C Recommendation</li></ul></li><li><blockquote><p>总结：CSS 的出现是<strong>为了美化 HTML</strong>的，并且让<strong>结构（HTML）与样式（CSS）分离</strong>；</p></blockquote><ul><li><blockquote><p>美化方式一：为 HTML<strong>添加各种各样的样式</strong>，比如颜色、字体、大小、下划线等等</p></blockquote></li><li><blockquote><p>美化方式二：对 HTML<strong>进行布局</strong>，按照某种结构显示（CSS 进行布局 – 浮动、flex、grid）</p></blockquote></li></ul></li></ul><br /><ul><li><p>link 元素是<strong>外部资源链</strong>接元素，规范了<strong>文档与外部资源</strong>的关系</p><ul><li><p>放入 head 标签中</p></li><li><p>css、favicon 等</p></li><li><p>有 rel（指定链接类型 icon、stylesheet、dns-prefetch 等）、href（指定被链接资源的 URL）</p></li></ul></li></ul><br /><ul><li><p>进制的概念</p><ul><li>维基百科：<strong>进位制</strong>是一种记数方式，亦称<strong>进位计数法</strong>或<strong>位值计数法</strong></li><li>通俗理解：当数字达到某个值时，进一位(比如从 1 位变成 2 位)</li></ul></li><li><p>按照上面的来理解，<strong>二进制、八进制、十六进制</strong>：</p><ul><li><p>二进制：当数字到 1 的时候，用一位已经表示不了了，那么就进一位。</p></li><li><p>八进制：当数字到 7 的时候，用一位已经表示不了了，那么就进一位。</p></li><li><p>十六进制：等等，用一位如何表示十六个数字呢？a(10)、b(11)、c(12) 、 d(13) 、 e(14) 、 f(15)</p></li></ul></li></ul><br /><h2 id="RGB-的表示方法"><a href="#RGB-的表示方法" class="headerlink" title="RGB 的表示方法"></a><strong>RGB 的表示方法</strong></h2><ul><li>RGB 颜色可以通过以#为前缀的十六进制字符和函数（rgb()、rgba()）标记表示</li><li><strong>方式一：十六进制符号：</strong>#RRGGBB[AA]<ul><li>R（红）、G（绿）、B （蓝）和 A （alpha）是十六进制字符（0–9、A–F）；A 是可选的</li><li>比如，#ff0000 等价于#ff0000ff</li></ul></li><li><strong>方式二：十六进制符号：</strong>#RGB[A] R（红）、G（绿）、B （蓝）和 A （alpha）是十六进制字符（0–9、A–F）；<ul><li>三位数符号（#RGB）是六位数形式（#RRGGBB）的减缩版。</li><li>比如，#f09 和#ff0099 表示同一颜色。</li><li>四位数符号（#RGBA）是八位数形式（#RRGGBBAA）的减缩版。</li><li>比如，#0f38 和#00ff3388 表示相同颜色。</li></ul></li><li><strong>方式三：函数符：</strong> rgb[a](R, G, B[, A])<ul><li>R（红）、G（绿）、B （蓝）可以是<code>&lt;number&gt;</code>（数字），或者<code>&lt;percentage&gt;</code>（百分比），255 相当于 100%。</li><li>A（alpha）可以是 0 到 1 之间的数字，或者百分比，数字 1 相当于 100%（完全不透明）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础常识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
